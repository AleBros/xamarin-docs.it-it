---
title: Wrapper callable Android per Xamarin.Android
ms.prod: xamarin
ms.assetid: C33E15FA-1E2B-819A-C656-CA588D611492
ms.technology: xamarin-android
author: davidortinau
ms.author: daortin
ms.date: 02/15/2018
ms.openlocfilehash: ef2f8e0375786ba7b627fdf75545cbb48318c1aa
ms.sourcegitcommit: 854798de42566750d9c70b6d0539b7ee73ff6ddc
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/20/2020
ms.locfileid: "81646595"
---
# <a name="android-callable-wrappers-for-xamarinandroid"></a>Wrapper callable Android per Xamarin.Android

Android Callable Wrapper (ACW) sono necessari ogni volta che il runtime Android richiama il codice gestito. Questi wrapper sono necessari perché non è possibile registrare le classi con ART (il runtime Android) in fase di esecuzione. (In particolare, la [funzione JNI DefineClass()](https://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/functions.html#wp15986) non è supportata dal runtime Android. Android Callable Wrapper compensa quindi la mancanza di supporto per la registrazione del tipo di runtime. 

*Ogni volta* Il codice Android `virtual` deve eseguire un `overridden` metodo di interfaccia o o implementato nel codice gestito, Xamarin.Android deve fornire un proxy Java in modo che questo metodo venga inviato al tipo gestito appropriato. Questi tipi proxy Java sono codice Java con la "stessa" classe di base e l'elenco di interfacce Java del tipo gestito, implementando gli stessi costruttori e dichiarando eventuali metodi di classe e interfaccia di base sottoposti a override. 

I wrapper richiamabili Android vengono generati dal programma **monodroid.exe** durante il processo di [compilazione:](~/android/deploy-test/building-apps/build-process.md)vengono generati per tutti i tipi che (direttamente o indirettamente) ereditano [Java.Lang.Object](xref:Java.Lang.Object). 

## <a name="android-callable-wrapper-naming"></a>Denominazione wrapper richiamabile Android

I nomi dei pacchetti per Android Callable Wrapper sono basati sull'MD5SUM del nome completo dell'assembly del tipo esportato. Questa tecnica di denominazione consente di renderlo disponibile dallo stesso nome di tipo completo da parte di assembly diversi senza introdurre un errore di creazione di pacchetti. 

A causa di questo schema di denominazione MD5SUM, non è possibile accedere direttamente ai tipi in base al nome. Ad esempio, `adb` il comando seguente non `my.ActivityType` funzionerà perché il nome del tipo non viene generato per impostazione predefinita:For example, the following command will not work because the type name is not generated by default: 

```shell
adb shell am start -n My.Package.Name/my.ActivityType
```

Inoltre, è possibile che vengano visualizzati errori simili ai seguenti se si tenta di fare riferimento a un tipo in base al nome:

```shell
java.lang.ClassNotFoundException: Didn't find class "com.company.app.MainActivity"
on path: DexPathList[[zip file "/data/app/com.company.App-1.apk"] ...
```

Se *si* richiede l'accesso ai tipi in base al nome, è possibile dichiarare un nome per tale tipo in una dichiarazione di attributo. Ad esempio, di seguito è riportato il codice `My.ActivityType`che dichiara un'attività con il nome completo :

```csharp
namespace My {
    [Activity]
    public partial class ActivityType : Activity {
        /* ... */
    }
}
```

La `ActivityAttribute.Name` proprietà può essere impostata per dichiarare in modo esplicito il nome di questa attività:The property can be set to explicitly declare the name of this activity: 

```csharp
namespace My {
    [Activity(Name="my.ActivityType")]
    public partial class ActivityType : Activity {
        /* ... */
    }
}
```

Dopo aver aggiunto questa `my.ActivityType` impostazione di proprietà, è `adb` possibile accedervi per nome da codice esterno e da script. L'attributo `Name` può essere impostato `Activity` `Application`per `Service` `BroadcastReceiver`molti `ContentProvider`tipi diversi, tra cui , , , e : 

- [ActivityAttribute.Name](xref:Android.App.ActivityAttribute.Name)
- [ApplicationAttribute.Name](xref:Android.App.ApplicationAttribute.Name)
- [ServiceAttribute.Name](xref:Android.App.ServiceAttribute.Name)
- [BroadcastReceiverAttribute.Name](xref:Android.Content.BroadcastReceiverAttribute.Name)
- [ContentProviderAttribute.Name](xref:Android.Content.ContentProviderAttribute.Name)

La denominazione ACW basata su MD5SUM è stata introdotta in Xamarin.Android 5.0. Per ulteriori informazioni sulla denominazione degli attributi, vedere [RegisterAttribute](xref:Android.Runtime.RegisterAttribute). 

## <a name="implementing-interfaces"></a>Implementazione di interfacce

In alcuni casi potrebbe essere necessario implementare un'interfaccia Android, ad esempio [Android.Content.IComponentCallbacks](xref:Android.Content.IComponentCallbacks). Poiché tutte le classi e l'interfaccia Android estendono l'interfaccia [Android.Runtime.IJavaObject,](xref:Android.Runtime.IJavaObject) sorge la domanda: come implementiamo `IJavaObject`? 

La domanda è stata risolta sopra: `IJavaObject` il motivo per cui tutti i tipi Android devono implementare è in modo che Xamarin.Android ha un wrapper richiamabile Android per fornire ad Android, vale a dire un proxy Java per il tipo specificato. Poiché **monodroid.exe** `Java.Lang.Object` cerca solo `Java.Lang.Object` le `IJavaObject`sottoclassi e implementa `Java.Lang.Object`, la risposta è ovvia: sottoclasse : 

```csharp
class MyComponentCallbacks : Java.Lang.Object, Android.Content.IComponentCallbacks {

    public void OnConfigurationChanged (Android.Content.Res.Configuration newConfig)
    {
        // implementation goes here...
    } 

    public void OnLowMemory ()
    {
        // implementation goes here...
    }
}
```

## <a name="implementation-details"></a>Dettagli dell'implementazione

*Il resto di questa pagina fornisce i dettagli di implementazione soggetti a modifiche senza preavviso* (e viene presentato qui solo perché gli sviluppatori saranno curiosi di sapere cosa sta succedendo). 

Ad esempio, data l'origine seguente di C:

```csharp
using System;
using Android.App;
using Android.OS;

namespace Mono.Samples.HelloWorld
{
    public class HelloAndroid : Activity
    {
        protected override void OnCreate (Bundle savedInstanceState)
        {
            base.OnCreate (savedInstanceState);
            SetContentView (R.layout.main);
        }
    }
}
```

Il programma **mandroid.exe** genererà il seguente Android Callable Wrapper: 

```java
package mono.samples.helloWorld;

public class HelloAndroid
    extends android.app.Activity
{
    static final String __md_methods;
    static {
        __md_methods = "n_onCreate:(Landroid/os/Bundle;)V:GetOnCreate_Landroid_os_Bundle_Handler\n" + "";
        mono.android.Runtime.register (
            "Mono.Samples.HelloWorld.HelloAndroid, HelloWorld, Version=1.0.0.0, 
            Culture=neutral, PublicKeyToken=null", HelloAndroid.class, __md_methods);
    }

    public HelloAndroid ()
    {
        super ();
        if (getClass () == HelloAndroid.class)
            mono.android.TypeManager.Activate (
                "Mono.Samples.HelloWorld.HelloAndroid, HelloWorld, Version=1.0.0.0, 
                Culture=neutral, PublicKeyToken=null", "", this, new java.lang.Object[] {  });
    }

    @Override
    public void onCreate (android.os.Bundle p0)
    {
        n_onCreate (p0);
    }

    private native void n_onCreate (android.os.Bundle p0);
}
```

Si noti che la `native` classe base viene mantenuta e vengono fornite dichiarazioni di metodo per ogni metodo sottoposto a override all'interno del codice gestito. 
