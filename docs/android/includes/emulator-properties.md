|Proprietà|Descrizione|Opzioni|
|--- |--- |--- |
|`abi.type`|**Tipo ABI** &ndash; specifica il tipo di interfaccia ABI (interfaccia applicativa binaria) del dispositivo emulato. Il **x86** opzione è per l'istruzione set comunemente noto come "x86" o "IA-32". Il **x86_64** opzione è per x86 a 64 bit il set di istruzioni. Il **armeabi v7a** opzione viene utilizzata per il set con v7-a estensioni ARM di istruzioni ARM. Il **arm64 v8a** opzione viene utilizzata per il set di istruzioni ARM che supporta AArch64.|x86, x86_64, armeabi-v7a, arm64-v8a|
|`disk.cachePartition`|**Memorizzare nella cache partizione** &ndash; determina se il dispositivo emulato utilizzerà un **/cache** partizione nel dispositivo. Il **/cache** partizione (che è inizialmente vuota) è il percorso in cui Android archivia i dati utilizzati di frequente e i componenti dell'app. Se impostato su **non**, l'emulatore non utilizzerà un **/cache** partizione e l'altro `disk.cache` impostazioni verranno ignorate.|yes, no|
|`disk.cachePartition.path`|**Percorso della partizione cache** &ndash; specifica un file di immagine partizione cache nel computer di sviluppo. L'emulatore utilizzerà il file per il **/cache** partizione. Immettere un percorso assoluto o un percorso relativo alla directory dei dati dell'emulatore. Se non è impostata, l'emulatore consente di creare un file temporaneo vuoto denominato **cache.img** nel computer di sviluppo. Se il file non esiste, viene creato un file vuoto. Questa opzione viene ignorata se `disk.cachePartition` è impostato su **non**.||
|`disk.cachePartition.size`|**Memorizzare nella cache di dimensione di partizione** &ndash; le dimensioni del file di partizione di cache (in megabyte). In genere non è necessario impostare questa opzione, a meno che l'app non scaricherà file molto grandi, che superano la dimensione della cache predefinita di 66 megabyte. Questa opzione viene ignorata se `disk.cachePartition` è impostato su **non**.||
|`disk.dataPartition.initPath`|**Percorso iniziale per la partizione di dati** &ndash; specifica il contenuto iniziale della partizione di dati. Dopo la cancellazione dei dati utente, l'emulatore copia il contenuto del file specificato per i dati utente (per impostazione predefinita, **userdata qemu.img**) anziché **userdata.img** nella versione iniziale.||
|`disk.dataPartition.path`|**Percorso della partizione di dati** &ndash; specifica il file della partizione dati utente. Per configurare un file di dati utente persistente, immettere il nome e il percorso del file nel computer di sviluppo. Se il file non esiste, l'emulatore crea un'immagine dal file predefinito **userdata.img**, archivia il nome di file specificato da `disk.dataPartition.path`, e mantiene i dati utente ad esso quando l'emulatore viene arrestato. Se non si specifica un percorso, il file predefinito è denominato **userdata qemu.img**. Il valore speciale  **<temp>**  fa sì che l'emulatore creare e utilizzare un file temporaneo. Se `disk.dataPartition.initPath` è impostato, verrà copiato il contenuto del file disk.dataPartition.path in fase di avvio. Si noti che questa opzione non può essere vuota.||
|`disk.dataPartition.size`|**Dimensioni della partizione dati** &ndash; specifica le dimensioni della partizione di dati utente in megabyte.||
|`disk.ramdisk.path`|**Percorso RAMDisk** &ndash; percorso dell'immagine di avvio partizione (ramdisk). L'immagine ramdisk è un subset dell'immagine di sistema che viene caricata dal kernel prima del montaggio dell'immagine di sistema. L'immagine ramdisk in genere contiene file binari e script di inizializzazione usati in fase di avvio. Se questa opzione non è specificata, il valore predefinito è **ramdisk.img** nella directory di sistema dell'emulatore.||
|`disk.snapStorage.path`|**Percorso di archiviazione degli snapshot** &ndash; percorso del file di archiviazione di snapshot in cui vengono archiviati tutti gli snapshot. Tutti gli snapshot creati durante l'esecuzione verranno salvati in questo file. È possibile ripristinare solo gli snapshot salvati in questo file durante l'esecuzione dell'emulatore. Se questa opzione non è specificata, il valore predefinito è snapshots.img nella directory di dati dell'emulatore.||
|`disk.systemPartition.initPath`|**Percorso di sistema partizione init** &ndash; percorso della copia di sola lettura del file di immagine del sistema; in particolare, la partizione che contiene le librerie di sistema e i dati corrispondenti a livello dell'API e una variante. Se questo percorso viene omesso, il valore predefinito è system.img nella directory di sistema dell'emulatore.||
|`disk.systemPartition.path`|**Percorso di partizione di sistema** &ndash; percorso dell'immagine di partizione di sistema di lettura/scrittura. Se questo percorso non è impostato, verrà creato e inizializzato dal contenuto del file specificato da un file temporaneo `disk.systemPartition.initPath`.||
|`disk.systemPartition.size`|**Dimensione di partizione di sistema** &ndash; la dimensione ideale della partizione di sistema (in megabyte). La dimensione viene ignorata se l'immagine della partizione di sistema effettiva è superiore a questa impostazione. In caso contrario, specifica la dimensione massima che può raggiungere il file della partizione di sistema.||
|`hw.accelerometer`|**Accelerometro** &ndash; determina se il dispositivo emulato contiene un sensore accelerometro. L'accelerometro consente al dispositivo di determinare l'orientamento (usato per la rotazione automatica). L'accelerometro segnala l'accelerazione del dispositivo lungo i tre assi del sensore.|yes, no|
|`hw.audioInput`|**Supporto della registrazione audio** &ndash; determina se il dispositivo emulato possibile registrare l'audio.|yes, no|
|`hw.audioOutput`|**Supporto per la riproduzione di audio** &ndash; determina se il dispositivo emulato possibile riprodurre l'audio.|yes, no|
|`hw.battery`|**Il supporto della batteria** &ndash; determina se il dispositivo emulato può essere eseguito su una batteria.|yes, no|
|`hw.camera`|**Supporto della fotocamera** &ndash; determina se il dispositivo emulato dispone di una fotocamera.|yes, no|
|`hw.camera.back`|**Fotocamera posteriore** &ndash; configura la fotocamera posteriore (le facce ottica dall'utente). Se si utilizza una webcam nel computer di sviluppo per simulare la fotocamera posteriore del dispositivo emulato, questo valore deve essere impostato su webcam*n*, dove _n_ seleziona webcam (se si dispone solo una webcam, Scegliere **webcam0**). Se impostato su emulati, l'emulatore simula la fotocamera nel software. Per disabilitare la fotocamera posteriore, impostare questo valore su none. Se si abilita la fotocamera posteriore, assicurarsi di abilitare anche `hw.camera`.|emulated, none, webcam0|
|`hw.camera.front`|**Fotocamera anteriore** &ndash; configura la fotocamera posta sul davanti (le facce obiettivo verso l'utente). Se si utilizza una webcam nel computer di sviluppo per simulare la fotocamera posta sul davanti dispositivo emulato, questo valore deve essere impostato su webcam*n*, dove _n_ seleziona webcam (se si dispone di un solo webcam Scegliere **webcam0**). Se impostato su emulati, l'emulatore simula una fotocamera nel software. Per disabilitare la fotocamera posta sul davanti, impostare questo valore su none. Se si abilita la fotocamera posta sul davanti, assicurarsi di abilitare anche `hw.camera`.|emulated, none, webcam0|
|`hw.camera.maxHorizontalPixels`|**Pixel fotocamera orizzontale massimo** &ndash; consente di configurare la risoluzione massima orizzontale della fotocamera del dispositivo emulato (in pixel).||
|`hw.camera.maxVerticalPixels`|**Pixel fotocamera verticale massimo** &ndash; consente di configurare la risoluzione verticale massima della fotocamera del dispositivo emulato (in pixel).||
|`hw.cpu.arch`|**Architettura della CPU** &ndash; architettura della CPU per essere emulate dal dispositivo virtuale. Se si utilizza per l'accelerazione hardware Intel HAXM, selezionare **x86** per una CPU a 32 bit. Selezionare **x86_64** per un dispositivo con accelerazione HAXM a 64 bit. (Assicurarsi di installare l'immagine del sistema Intel x86 corrispondente in SDK Manager: ad esempio, Intel x86 Atom o Intel x86 Atom_64.) Per simulare una CPU ARM, selezionare **arm** per 32 bit o selezionare **arm64** per una CPU ARM a 64 bit. Tenere presente che i dispositivi virtuali basati su ARM verranno eseguiti molto più lentamente rispetto a quelli basati su x86, perché l'accelerazione hardware non è disponibile per ARM.|x86, x86_64, arm, arm64|
|`hw.cpu.model`|**Modello di CPU** &ndash; questo valore viene in genere lasciato non impostato (verrà impostata su un valore derivato da `hw.cpu.arch` se non è impostato in modo esplicito). Può tuttavia essere impostato su una stringa specifica dell'emulatore per uso sperimentale.||
|`hw.dPad`|**Le chiavi pad direzionale** &ndash; determina se il dispositivo emulato supporta chiavi direzionale (pad direzionale). Un tasto direzionale in genere include quattro tasti per indicare il controllo direzionale.|yes, no|
|`hw.gps`|**Supporto GPS** &ndash; determina se il dispositivo emulato dispone di un ricevitore GPS (Global Positioning System).|yes, no|
|`hw.gpu.enabled`|**Emulazione di GPU** &ndash; determina se il dispositivo emulato supporta l'emulazione di GPU. Se abilitata, l'emulazione della GPU usa Open GL for Embedded Systems (OpenGL ES) per il rendering della grafica 2D e 3D sullo schermo e l'impostazione associata per la modalità di emulazione della GPU determina il modo in cui viene implementata l'emulazione della GPU.|yes, no|
|`hw.gpu.mode`|**Modalità di emulazione di GPU** &ndash; determina l'implementazione di emulazione di GPU dall'emulatore. Se si seleziona automatico, l'emulatore verrà scelto l'accelerazione hardware e software in base all'impostazione di computer di sviluppo. Se si seleziona l'host, l'emulatore utilizzerà eseguire emulazione GPU per un rendering più veloce processore grafico del computer di sviluppo. Se la GPU non è compatibile con l'emulatore e si è connessi a Windows, è possibile provare angolo anziché host. La modalità di angolo Usa DirectX per offrire prestazioni simili all'host. Se si seleziona mesa, l'emulatore utilizzerà la libreria software 3D Mesa per il rendering della grafica. Selezionare mesa se si verificano problemi durante il rendering tramite il processore di grafica del computer di sviluppo. La modalità swiftshader può essere utilizzata per eseguire il rendering di grafica nel software leggermente inferiore delle prestazioni rispetto all'utilizzo di GPU del computer. L'opzione off (Disabilita grafica hardware emulazione) è un'opzione obsoleta che può causare rendering inappropriato per alcuni elementi e pertanto non è consigliata.|auto, host, mesa, angle, swiftshader, off|
|`hw.gsmModem`|**Supporto di modem GSM** &ndash; determina se il dispositivo emulato include un modem che supporta il sistema radio di telefonia GSM (Global System for Mobile Communications).|yes, no|
|`hw.initialOrientation`|**Orientamento dello schermo iniziale** &ndash; configura l'orientamento della schermata iniziale del dispositivo emulato (modalità verticale o orizzontale). In modalità verticale, l'altezza dello schermo è superiore alla larghezza. In modalità orizzontale, la larghezza dello schermo è superiore all'altezza. Quando si esegue il dispositivo emulato, è possibile modificare l'orientamento se sono supportati sia l'orientamento verticale che quello orizzontale nel profilo del dispositivo.|portrait, landscape|
|`hw.keyboard`|**Supporto della tastiera** &ndash; determina se il dispositivo emulato supporta una tastiera QWERTY.|yes, no|
|`hw.keyboard.charmap`|**Nome charmap tastiera** &ndash; il nome di charmap l'hardware per questo dispositivo. Nota: Il valore predefinito deve sempre essere **qwerty2** a meno che non è stato modificato di conseguenza l'immagine del sistema. Questo nome viene inviato al kernel in fase di avvio. L'uso di un nome errato renderà inutilizzabile il dispositivo virtuale.||
|`hw.keyboard.lid`|**Supporto coperchio tastiera** &ndash; se il supporto della tastiera è abilitato, questa impostazione determina se la tastiera QWERTY può essere chiusa/nascosta o aperto/visibili. Questa impostazione verrà ignorata se hw.keyboard è impostata su false. Nota: il valore predefinito è false se il dispositivo emulato è destinato a livello dell'API 12 o versione successiva.|yes, no|
|`hw.lcd.backlight`|**Retroilluminazione LCD** &ndash; determina se una retroilluminazione LCD viene simulata dal dispositivo emulato.|yes, no|
|`hw.lcd.density`|**Densità LCD** &ndash; la densità dello schermo LCD emulato, misurata in pixel indipendenti dal densità o punto di distribuzione (dp è un'unità virtuale pixel). Quando l'impostazione è 160 dp, ogni dp corrisponde a un pixel fisico. In fase di esecuzione, Android usa questo valore per selezionare e ridimensionare le risorse o gli asset appropriati per il rendering corretto della visualizzazione.|120, 160, 240, 213, 320|
|`hw.lcd.depth`|**Profondità di colore LCD** &ndash; la profondità del buffer frame emulata che contiene la bitmap per guidare la visualizzazione LCD di colore. Questo valore può essere 16 bit (65.536 colori possibili) o 32 bit (16.777.216 colori più trasparenza). L'impostazione a 32 bit può rallentare leggermente l'esecuzione dell'emulatore, ma con una maggiore precisione dei colori.|16, 32|
|`hw.lcd.height`|**Altezza in pixel LCD** &ndash; il numero di pixel che costituiscono la dimensione verticale dello schermo LCD emulata.||
|`hw.lcd.width`|**Larghezza in pixel LCD** &ndash; il numero di pixel che costituiscono la dimensione orizzontale del monitor LCD emulata.||
|`hw.mainKeys`|**Le chiavi Back/Home hardware** &ndash; determina se il dispositivo emulato supporta hardware nuovo e pulsanti di navigazione Home. È possibile impostare questo valore **Sì** se i pulsanti vengono implementati solo nel software. Se `hw.mainKeys` è impostato su **Sì**, l'emulatore non verrà visualizzati i pulsanti di navigazione nella schermata, ma è possibile utilizzare il pannello lato emulatore per questi pulsanti "premere".|yes, no|
|`hw.ramSize`|**Dimensioni della RAM dispositivo** &ndash; la quantità di RAM fisica sul dispositivo emulato, in megabyte. Il valore predefinito verrà calcolato dalle dimensioni dello schermo o dalla versione dell'interfaccia. L'aumento delle dimensioni può velocizzare l'esecuzione dell'emulatore, ma a scapito di una maggiore richiesta di risorse del computer di sviluppo.||
|`hw.screen`|**Tipo di schermata tocco** &ndash; definisce il tipo di schermata del dispositivo emulata. Multi-touch screen possibile tenere traccia di più di due dita sull'interfaccia tocco. Un touch-screen può rilevare solo gli eventi tocco di un singolo dito. No-touch screen non rileva gli eventi tocco.|touch, multi-touch, no-touch|
|`hw.sdCard`|**Supporto SDCard** &ndash; determina se il dispositivo emulato supporta l'inserimento e rimozione di schede SD (Secure Digital) virtuale. L'emulatore utilizza le immagini disco montabile archiviate nel computer di sviluppo per simulare le partizioni di dispositivi di scheda SD effettivi (vedere hw.sdCard.path).|yes, no|
|`sdcard.size`|**Dimensioni SDCard** &ndash; specifica le dimensioni del file di scheda SD virtuale nella posizione specificata da `hw.sdCard.path`. disponibile per il dispositivo (in byte). Se la dimensione è un semplice numero intero, specifica la dimensione in byte. È inoltre possibile specificare la dimensione in kilobyte, megabyte e gigabyte aggiungendo K, M o G alla dimensione. La dimensione minima è 9M e la dimensione massima è 1023G.||
|`hw.sdCard.path`|**Percorso dell'immagine SDCard** &ndash; specifica il nome e il percorso di un file di immagine SD card partizione nel computer di sviluppo. Ad esempio, è possibile impostare questo percorso **C:\sd\sdcard.img** in Windows.||
|`hw.sensors.magnetic_field`|**Sensore di campo magnetico** &ndash; determina se il dispositivo emulato supporta un sensore campo magnetico. Il sensore di campo magnetico (anche denominato magnetometro) segnala il campo geomagnetico dell'ambiente misurato lungo i tre assi del sensore. Abilitare questa impostazione per le app che richiedono l'accesso a una lettura della bussola. Ad esempio, un'app di navigazione può usare questo sensore per rilevare la direzione verso cui è rivolto l'utente.|yes, no|
|`hw.sensors.orientation`|**Sensore di orientamento** &ndash; determina se il dispositivo emulato fornisce i valori del sensore orientamento. Il sensore di orientamento misura i gradi di rotazione di un dispositivo intorno a tutti e tre gli assi fisici (x, y, z). Si noti che il sensore di orientamento è stato deprecato a partire da Android 2.2 (livello API 8).|yes, no|
|`hw.sensors.proximity`|**Sensore di prossimità** &ndash; determina se il dispositivo emulato supporta un sensore di prossimità. Questo sensore misura la prossimità di un oggetto rispetto allo schermo di un dispositivo. Questo sensore è in genere usato per determinare se un ricevitore viene tenuto vicino all'orecchio di una persona.|yes, no|
|`hw.sensors.temperature`|**Sensore di temperatura** &ndash; determina se il dispositivo emulato supporta un sensore di temperatura. Sensore di questa misura la temperatura del dispositivo in gradi Celsius (&deg;C).|yes, no|
|`hw.touchScreen`|**Supporto touchscreen** &ndash; determina se il dispositivo emulato supporta un touch screen. Il touchscreen viene usato per la modifica diretta degli oggetti sullo schermo.|yes, no|
|`hw.trackBall`|**Supporto trackball** &ndash; determina se il dispositivo emulato supporta un trackball.|yes, no|
|`hw.useext4`|**Supporto di file system EXT4** &ndash; determina se il dispositivo emulato utilizza il file system Linux EXT4 per le partizioni. Poiché il tipo di file system ora viene rilevato automaticamente, questa opzione è deprecata e viene ignorata.|No|
|`kernel.newDeviceNaming`|**Denominazione del kernel nuovo dispositivo** &ndash; utilizzato per specificare se il kernel richiede un nuovo schema di denominazione di dispositivo. In genere viene usato con i kernel Linux 3.10 e versioni successive. Se impostato su **autodetect**, l'emulatore rileverà automaticamente se il kernel richiede un nuovo schema di denominazione di dispositivo.|autodetect, yes, no|
|`kernel.parameters`|**Parametri del kernel** &ndash; specifica la stringa di parametri di avvio del kernel Linux. Per impostazione predefinita, questa impostazione è vuota.||
|`kernel.path`|**Percorso del kernel** &ndash; specifica il percorso per il kernel Linux. Se questo percorso viene omesso, l'emulatore Cerca nella directory di sistema dell'emulatore per kernel ranchu.||
|`kernel.supportsYaffs2`|**Supporto della partizione YAFFS2** &ndash; determina se il kernel supporta YAFFS2 partizioni (ancora un'altra Flash File System 2). In genere, si applica solo ai kernel precedenti a Linux 3.10. Se impostato su **autodetect** l'emulatore rileverà automaticamente se il kernel possibile montare YAFFS2 file System.|autodetect, yes, no|
|`skin.name`|**Nome di interfaccia** &ndash; il nome di un'interfaccia dell'emulatore Android. Un'interfaccia è una raccolta di file che definisce gli elementi visivi e di controllo di una visualizzazione dell'emulatore. Descrive l'aspetto della finestra del dispositivo virtuale Android nel computer di sviluppo. Un'interfaccia descrive le dimensioni dello schermo, i pulsanti e la struttura complessiva, ma non influisce sulle operazioni dell'app.||
|`skin.path`|**Percorso di interfaccia** &ndash; percorso di directory che contiene i file di interfaccia emulatore specificato nella skin.name questa directory contiene i file di layout hardware.ini e file di immagine per il visualizzazione di elementi dell'interfaccia.||
|`skin.dynamic`|**Interfaccia dinamica** &ndash; o meno l'interfaccia è dinamico. L'interfaccia dell'emulatore è un'interfaccia dinamica se l'emulatore deve creare un'interfaccia di una determinata dimensione in base a una larghezza e un'altezza specificate.|No|

